{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Algorithmes G\u00e9n\u00e9tiques 2: Peindre Vermeer","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Packages</p> <p>Les Algorithmes G\u00e9n\u00e9tiques 2: Peindre Vermeer est un probl\u00e8me dans lequel un algorithme g\u00e9n\u00e9tique peut \u00eatre appliqu\u00e9. L\u2019objectif est de cr\u00e9er une peinture g\u00e9n\u00e9r\u00e9e par ordinateur qui ressemble \u00e0 une peinture du c\u00e9l\u00e8bre peintre hollandais Johannes Vermeer.</p> <p>Pour appliquer un algorithme g\u00e9n\u00e9tique \u00e0 ce probl\u00e8me, nous devons d\u00e9finir un ensemble de g\u00e8nes, qui repr\u00e9sentent dans ce cas la couleur et la position de chaque coup de pinceau. Chaque individu de la population serait une peinture cr\u00e9\u00e9e en combinant les g\u00e8nes d\u2019une mani\u00e8re particuli\u00e8re. La fonction d\u2019adaptation serait utilis\u00e9e pour \u00e9valuer dans quelle mesure chaque peinture ressemble \u00e0 une v\u00e9ritable peinture de Vermeer.</p> <p>L\u2019algorithme g\u00e9n\u00e9tique serait ensuite appliqu\u00e9 de la mani\u00e8re suivante :</p> <ol> <li> <p>Initialisation : G\u00e9n\u00e9rer une population initiale d\u2019individus al\u00e9atoires.</p> </li> <li> <p>\u00c9valuation : \u00c9valuer la qualit\u00e9 de chaque individu en utilisant la fonction d\u2019adaptation.</p> </li> <li> <p>S\u00e9lection : S\u00e9lectionner un sous-ensemble d\u2019individus de la population pour servir de parents \u00e0 la prochaine g\u00e9n\u00e9ration.</p> </li> <li> <p>Croisement : Combiner les g\u00e8nes des parents s\u00e9lectionn\u00e9s pour cr\u00e9er de nouveaux individus.</p> </li> <li> <p>Mutation : Introduire des changements al\u00e9atoires dans les g\u00e8nes des nouveaux individus.</p> </li> <li> <p>Remplacement : Remplacer certains individus de la population actuelle par les nouveaux individus.</p> </li> <li> <p>Condition d\u2019arr\u00eat : V\u00e9rifier si la condition d\u2019arr\u00eat a \u00e9t\u00e9 atteinte. Si ce n\u2019est pas le cas, revenir \u00e0 l\u2019\u00e9tape 2.</p> </li> </ol> <p>Dans le cas de la peinture de Vermeer, la condition d\u2019arr\u00eat pourrait \u00eatre un nombre maximal de g\u00e9n\u00e9rations ou un niveau d\u2019adaptation seuil.</p> <p>En appliquant ces \u00e9tapes de mani\u00e8re it\u00e9rative, l\u2019algorithme g\u00e9n\u00e9tique am\u00e9liorera progressivement la qualit\u00e9 des peintures dans la population. Au fil du temps, l\u2019algorithme peut converger vers une peinture qui ressemble \u00e9troitement \u00e0 une peinture de Vermeer.</p>"},{"location":"#importer-les-packages","title":"Importer les Packages","text":"<p>Packages</p> <ul> <li> <p>os : est une biblioth\u00e8que standard de Python qui permet d\u2019interagir avec le syst\u00e8me d\u2019exploitation sous-jacent. Il fournit des fonctionnalit\u00e9s pour effectuer des op\u00e9rations li\u00e9es aux fichiers et aux r\u00e9pertoires, \u00e0 l\u2019environnement syst\u00e8me, aux processus, etc.</p> </li> <li> <p>NumPy : NumPy est une biblioth\u00e8que Python populaire pour le calcul scientifique qui fournit des structures de donn\u00e9es pour la repr\u00e9sentation de tableaux multidimensionnels et des fonctions pour manipuler ces tableaux.</p> </li> <li> <p>random : The random module in Python provides a suite of functions for generating random numbers.</p> </li> <li> <p>colour : est une biblioth\u00e8que de gestion des couleurs qui offre des fonctionnalit\u00e9s pour la manipulation, la conversion et la repr\u00e9sentation des couleurs dans diff\u00e9rents espaces colorim\u00e9triques.</p> </li> <li> <p>json : cette biblioth\u00e8que permet de travailler avec des donn\u00e9es au format JSON (JavaScript Object Notation). Le module json offre des fonctions pour la s\u00e9rialisation (encodage) et la d\u00e9s\u00e9rialisation (d\u00e9codage) des objets Python en JSON et vice versa.</p> </li> <li> <p>Pygame : est une biblioth\u00e8que Python populaire utilis\u00e9e pour d\u00e9velopper des jeux vid\u00e9o et des applications multim\u00e9dias interactives. Elle fournit des fonctionnalit\u00e9s pour la cr\u00e9ation de graphismes, la gestion des \u00e9v\u00e9nements, le traitement du son, la gestion des entr\u00e9es utilisateur et bien plus encore.</p> </li> </ul> <pre><code>import os\nimport numpy as np\nfrom numpy.random import choice, random, normal\nfrom colour import Color\nimport json\nimport pygame\n</code></pre>"},{"location":"#initialiser-un-organisme","title":"Initialiser un organisme","text":"<p>Organism</p> <p>Ce code d\u00e9finit la classe <code>Organism</code> (Organisme) qui repr\u00e9sente un organisme avec un ensemble de g\u00e8nes. Elle a les attributs suivants :</p> <p>chromosome: un tableau numpy repr\u00e9sentant les g\u00e8nes de l\u2019organisme. Les valeurs des g\u00e8nes sont limit\u00e9es entre 0 et 1 \u00e0 l\u2019aide de np.clip(genes, 0, 1).</p> <p>visual: une variable utilis\u00e9e pour stocker une repr\u00e9sentation visuelle de l\u2019organisme (probablement une image).</p> <p>fitness: une variable utilis\u00e9e pour stocker la valeur de fitness de l\u2019organisme.</p> <p>La classe <code>Organism</code> a \u00e9galement une m\u00e9thode <code>mutate</code> qui effectue une mutation sur l\u2019organisme. Les param\u00e8tres rate, scale et add sont les taux de mutation et d\u2019ajout, ainsi que l\u2019\u00e9chelle de mutation utilis\u00e9s dans le processus de mutation. Voici ce que fait la m\u00e9thode <code>mutate</code> :</p> <ul> <li> <p>Elle effectue une copie du chromosome de l\u2019organisme en utilisant np.copy(self.chromosome).</p> </li> <li> <p>Elle d\u00e9termine le nombre de mutations \u00e0 effectuer en fonction du taux de mutation : num_mutations = 1 + int(rate * n_gene).</p> </li> <li> <p>Elle it\u00e8re sur le nombre de mutations et effectue les mutations suivantes :</p> <ul> <li> <p>Si le r\u00e9sultat de random() &gt; add est True, une mutation sur un g\u00e8ne existant est effectu\u00e9e.</p> <ul> <li> <p>Un indice i est choisi al\u00e9atoirement \u00e0 partir des indices de caract\u00e9ristiques (n_feat).</p> </li> <li> <p>Une valeur al\u00e9atoire est ajout\u00e9e \u00e0 la caract\u00e9ristique s\u00e9lectionn\u00e9e dans un g\u00e8ne s\u00e9lectionn\u00e9 al\u00e9atoirement dans le chromosome.</p> </li> <li> <p>Si l\u2019indice est 3, la valeur de cette caract\u00e9ristique est modulo 1.</p> </li> </ul> </li> <li> <p>Sinon, une op\u00e9ration d\u2019ajout ou de suppression d\u2019un g\u00e8ne est effectu\u00e9e.</p> <ul> <li>Si random() &lt; 0.3, un g\u00e8ne est supprim\u00e9 al\u00e9atoirement du chromosome. Sinon, deux g\u00e8nes existants sont s\u00e9lectionn\u00e9s al\u00e9atoirement pour cr\u00e9er un nouveau g\u00e8ne. Le nouveau g\u00e8ne est obtenu en faisant la moyenne des deux g\u00e8nes s\u00e9lectionn\u00e9s et en ajoutant une perturbation. La troisi\u00e8me caract\u00e9ristique du nouveau g\u00e8ne est multipli\u00e9e par 0.2.</li> </ul> </li> </ul> </li> <li> <p>Enfin, la m\u00e9thode renvoie un nouvel objet <code>Organism</code> avec le chromosome mut\u00e9.</p> </li> </ul> <pre><code>class Organism:\ndef __init__(self, genes):\n\"\"\"\n        Initialise un organisme avec un ensemble de g\u00e8nes.\n        - genes : Matrice repr\u00e9sentant les g\u00e8nes de l'organisme.\n        \"\"\"\nself.chromosome = np.clip(genes, 0, 1)\nself.visual = None\nself.fitness = None\ndef mutate(self, rate=0.01, scale=0.3, add=0.3):\n\"\"\"\n        Effectue une mutation sur l'organisme avec des taux de mutation et une \u00e9chelle donn\u00e9s.\n        - rate : Taux de mutation, probabilit\u00e9 qu'un g\u00e8ne soit mut\u00e9.\n        - scale : \u00c9chelle de la mutation, d\u00e9termine l'amplitude des mutations.\n        - add : Probabilit\u00e9 d'ajouter un nouveau g\u00e8ne lors de la mutation.\n        Retourne un nouvel organisme mut\u00e9.\n        \"\"\"\nchromosome = np.copy(self.chromosome)\nn_gene, n_feat = chromosome.shape\n# Ici, nous pouvons ajouter/supprimer un g\u00e8ne ou muter un g\u00e8ne existant\nif random() &gt; add:\n# Mutation des caract\u00e9ristiques de nos g\u00e8nes\nnum_mutations = 1 + int(rate * n_gene)\n# \u00c0 mesure que nous effectuons plus de mutations, la taille des mutations diminue\nscale2 = scale / num_mutations\nfor i in range(num_mutations):\nif random() &gt; 0.5:\ni = 3\nelse:\ni = choice(n_feat)\nchromosome[choice(n_gene), i] += normal() * scale2\nif i == 3:\nchromosome[:, i] = np.mod(chromosome[:, i], 1)\nelse:\n# Ajout ou suppression d'un g\u00e8ne\nif random() &lt; 0.3:\nchromosome = np.delete(chromosome, choice(n_gene), axis=0)\nelse:\n# Lorsque nous ajoutons un g\u00e8ne, nous le ferons en m\u00e9langeant deux g\u00e8nes existants\n# et en le perturbant. Il est plus probable de trouver un bon g\u00e8ne de cette mani\u00e8re.\na, b = choice(n_gene, 2, replace=False)\ngene = np.atleast_2d(0.5 * (chromosome[a, :] + chromosome[b, :]))\ngene += scale * normal(size=(1, gene.size))\ngene[:, 2] *= 0.2\nchromosome = np.append(chromosome, gene, axis=0)\nreturn Organism(chromosome)\n</code></pre>"},{"location":"#initialiser-une-population","title":"Initialiser une population","text":"<p>Population</p> <p>La classe <code>Population</code> comprend plusieurs m\u00e9thodes pour simuler et faire \u00e9voluer une population d\u2019organismes bas\u00e9e sur une image de r\u00e9f\u00e9rence.</p> <p>Le code utilise la biblioth\u00e8que Pygame pour g\u00e9rer les graphiques et la manipulation d\u2019images. Voici un bref r\u00e9sum\u00e9 de chaque m\u00e9thode dans le code :</p> <ul> <li> <p>init(self, path) : M\u00e9thode constructeur qui charge une image de r\u00e9f\u00e9rence \u00e0 partir d\u2019un chemin de fichier donn\u00e9 en utilisant la biblioth\u00e8que Pygame, cr\u00e9e une surface sur laquelle dessiner et initialise une liste de population vide.</p> </li> <li> <p>draw(self, organism) : M\u00e9thode pour dessiner un organisme sur la surface en it\u00e9rant sur son chromosome et en dessinant des cercles avec une position, une taille et une couleur donn\u00e9es.</p> </li> <li> <p>spawn(self, pop_size=30, complexity=10) : M\u00e9thode pour g\u00e9n\u00e9rer une nouvelle population d\u2019organismes en cr\u00e9ant un certain nombre d\u2019organismes avec un nombre sp\u00e9cifi\u00e9 de g\u00e8nes dans chaque membre.</p> </li> <li> <p>calc_fitness(self, organism) : M\u00e9thode pour calculer la forme physique d\u2019un organisme en le dessinant et en le comparant \u00e0 l\u2019image de r\u00e9f\u00e9rence. La forme physique est calcul\u00e9e comme la diff\u00e9rence absolue moyenne n\u00e9gative entre les pixels des deux images.</p> </li> <li> <p>get_child(self, a, b) : M\u00e9thode pour g\u00e9n\u00e9rer un nouvel organisme en combinant deux organismes parents. Les g\u00e8nes de chaque parent sont choisis au hasard avec une probabilit\u00e9 de 70% pour le premier parent et de 30% pour le deuxi\u00e8me parent. Les g\u00e8nes communs sont m\u00e9lang\u00e9s dans le nouvel organisme.</p> </li> <li> <p>save(self, path) : M\u00e9thode pour enregistrer la population actuelle dans un fichier JSON.</p> </li> <li> <p>load(self, path) : M\u00e9thode pour charger une population \u00e0 partir d\u2019un fichier JSON.</p> </li> <li> <p>mutate_and_pick(self, organism, rate, scale, add, attempts=10) : M\u00e9thode pour muter un organisme en ajoutant une valeur al\u00e9atoire \u00e0 chaque g\u00e8ne avec une probabilit\u00e9 sp\u00e9cifi\u00e9e. La m\u00e9thode essaie de muter l\u2019organisme un certain nombre de fois sp\u00e9cifi\u00e9 et renvoie l\u2019organisme mut\u00e9 avec la forme physique la plus \u00e9lev\u00e9e.</p> </li> <li> <p>step(self, time, outdir, rate=0.01, scale=0.1, add=0.3) : M\u00e9thode pour simuler une \u00e9tape d\u2019\u00e9volution en cr\u00e9ant de nouvelles descendances, en les mutant et en conservant les plus adapt\u00e9es. La m\u00e9thode enregistre une image de l\u2019organisme le plus adapt\u00e9 dans un fichier et enregistre la population actuelle dans un fichier JSON.</p> </li> </ul> <pre><code>class Population:\ndef __init__(self, path):\n\"\"\"Charge l'image de r\u00e9f\u00e9rence et cr\u00e9e une surface sur laquelle on peut dessiner.\"\"\"\npygame.init()\nself.ref = pygame.surfarray.pixels3d(pygame.image.load(path))\nw, h, d = self.ref.shape\nself.screen = pygame.Surface((w, h))\nself.screen.fill((255, 255, 255))\nself.population = []\ndef draw(self, organism):\n\"\"\"Dessine un organisme en exprimant chaque g\u00e8ne.\"\"\"\nw, h, d = self.ref.shape\nscreen = self.screen.copy()\nfor gene in organism.chromosome:\nx, y, size, *hsl = gene\nposition = (int(x * w), int(y * h))\nc = tuple(map(lambda x: int(255 * x), Color(hsl=hsl).rgb))\npygame.draw.circle(screen, c, position, int((size * 0.3 + 0.01) * w))\nreturn screen\ndef spawn(self, pop_size=30, complexity=10):\n\"\"\"G\u00e9n\u00e8re une nouvelle population avec `complexity` g\u00e8nes dans chaque membre.\"\"\"\nfor i in range(pop_size):\norganism = Organism(random((complexity, 6)))\nself.population.append(organism) \nself.calc_fitness(organism)\nself.population = sorted(self.population, key=lambda x: -x.fitness)\ndef calc_fitness(self, organism):\n\"\"\"Calcule la forme physique d'un g\u00e8ne en le dessinant et en le comparant \u00e0 la r\u00e9f\u00e9rence.\"\"\"\nscreen = self.draw(organism)\ndiff = pygame.surfarray.pixels3d(screen) - self.ref\norganism.fitness = -np.mean(np.abs(diff)) - 1e-5 * organism.chromosome.size\norganism.visual = screen\ndef get_child(self, a, b):\n\"\"\"Croit un nouvel organisme en m\u00e9langeant les g\u00e8nes de longueur commune, en privil\u00e9giant le premier parent.\"\"\"\nnew_genes = []\nn_a, n_b = a.chromosome.shape[0], b.chromosome.shape[0]\nfor i in range(max(n_a, n_b)):\nif i &lt; n_a and i &lt; n_b:\nif random() &lt; 0.7:\nnew_genes.append(a.chromosome[i, :])\nelse:\nnew_genes.append(b.chromosome[i, :])\nelif i &lt; n_a:\nnew_genes.append(a.chromosome[i, :])\nelse:\nif random() &lt; 0.3:\nnew_genes.append(b.chromosome[i, :])\nchromosome = np.array(new_genes)\no = Organism(chromosome)\nself.calc_fitness(o)\nreturn o\ndef save(self, path):\n\"\"\"Enregistre la population dans un fichier JSON.\"\"\"\nout = [o.chromosome.tolist() for o in self.population]\nwith open(path, \"w\") as f:\njson.dump(out, f)\ndef load(self, path):\n\"\"\"Charge la population \u00e0 partir d'un fichier JSON.\"\"\"\nwith open(path) as f:\ninp = json.load(f)\nself.population = [Organism(np.array(x)) for x in inp]\nfor o in self.population:\nself.calc_fitness(o)\ndef mutate_and_pick(self, organism, rate, scale, add, attempts=10):\n\"\"\" Muter l'organisme un certain nombre de fois pour essayer d'obtenir quelque chose de meilleur \"\"\"\nfor i in range(attempts):\no = organism.mutate(rate=rate, scale=scale, add=add)\nself.calc_fitness(o)\nif o.fitness &gt; organism.fitness:\nreturn o\nreturn organism\ndef step(self, time, outdir, rate=0.01, scale=0.1, add=0.3):\n\"\"\" Avancer dans le temps en cr\u00e9ant des enfants, en les mutant, puis en laissant les plus aptes survivre \"\"\"\nnew_orgs = []\nweights = 1 - np.linspace(0, 0.2, len(self.population))\nfor i in range(len(self.population)):\na, b = choice(self.population, 2, replace=True, p=weights / weights.sum())\nchild = self.get_child(a, b)\nnew_orgs.append(self.mutate_and_pick(child, rate, scale, add))\nfor o in new_orgs:\nself.calc_fitness(o)\nsorted_orgs = sorted(new_orgs, key=lambda x: -x.fitness)\nself.population = sorted_orgs[:len(self.population)]\npath = outdir + f\"{time:04d}.png\"\npygame.image.save(self.population[0].visual, path)\nself.save(outdir + \"save.json\")\n</code></pre>"},{"location":"#faire-evoluer-la-population-dorganismes","title":"Faire Evoluer la population d\u2019organismes","text":"<p>evolve</p> <p>La fonction <code>evolve</code> effectue l\u2019\u00e9volution de la population d\u2019organismes en utilisant les param\u00e8tres de mutation fournis.</p> <p>La fonction commence par cr\u00e9er une instance de la classe <code>Population</code> en fournissant le chemin d\u2019acc\u00e8s \u00e0 l\u2019image de r\u00e9f\u00e9rence. Ensuite, elle cr\u00e9e un r\u00e9pertoire de sortie pour enregistrer les images g\u00e9n\u00e9r\u00e9es au cours de l\u2019\u00e9volution.</p> <p>Si une sauvegarde de population existe d\u00e9j\u00e0, elle est charg\u00e9e \u00e0 partir du fichier JSON correspondant. Le num\u00e9ro de l\u2019\u00e9tape de d\u00e9part est \u00e9galement d\u00e9termin\u00e9 en se basant sur le nom du dernier fichier d\u2019image enregistr\u00e9.</p> <p>Si aucune sauvegarde de population n\u2019existe, une population initiale est g\u00e9n\u00e9r\u00e9e en appelant la m\u00e9thode spawn de l\u2019instance de <code>Population</code>.</p> <p>Ensuite, la boucle principale de l\u2019\u00e9volution d\u00e9marre, it\u00e9rant sur le nombre d\u2019\u00e9tapes sp\u00e9cifi\u00e9. \u00c0 chaque \u00e9tape, la m\u00e9thode step de l\u2019instance de <code>Population</code> est appel\u00e9e pour effectuer une it\u00e9ration de l\u2019\u00e9volution. Les param\u00e8tres de mutation (rate, scale, add_chance) sont transmis \u00e0 cette m\u00e9thode.</p> <p>L\u2019image du meilleur organisme de chaque \u00e9tape est enregistr\u00e9e dans le r\u00e9pertoire de sortie, et la population actuelle est sauvegard\u00e9e dans un fichier JSON.</p> <pre><code>def evolve(rate, scale, add_chance, steps=700000):\npop = Population(\"/content/test.jpg\")\noutdir = f\"genetic2/output/\"\nos.makedirs(outdir, exist_ok=True)\nsave = outdir + \"save.json\"\n# Chargement de la population pr\u00e9c\u00e9demment sauvegard\u00e9e si elle existe\nif os.path.exists(save):\npop.load(save)\nstart = int(sorted(os.listdir(outdir))[-2][:-4]) * 2\nelse:\n# G\u00e9n\u00e9ration initiale de la population\npop.spawn(complexity=20)\nstart = 0\n# \u00c9volution de la population pendant le nombre d'\u00e9tapes sp\u00e9cifi\u00e9\nfor i in range(start, steps):\npop.step(i, outdir, rate=rate, scale=scale, add=add_chance)\n</code></pre>"},{"location":"#executer-le-processus-devolution-de-la-population-dorganismes","title":"Ex\u00e9cuter le processus d\u2019\u00e9volution de la population d\u2019organismes","text":"<p>evolve(0.01, 0.1, 0.01)</p> <p>La fonction <code>evolve(0.01, 0.1, 0.01)</code> ex\u00e9cute le processus d\u2019\u00e9volution de la population d\u2019organismes en utilisant les param\u00e8tres suivants :</p> <p>Taux de mutation : 0,01 (1% de chance de mutation)</p> <p>\u00c9chelle (scale) : 0,1 (distribution normale avec un \u00e9cart-type de 0,1)</p> <p>Chance d\u2019ajout ou de suppression : 0,01 (1% de chance d\u2019ajout ou de suppression de g\u00e8nes)</p> <ul> <li> <p> Cela signifie que lors de chaque it\u00e9ration de l\u2019\u00e9volution, les organismes de la population seront soumis \u00e0 des mutations avec une probabilit\u00e9 de 0,01 (1% de chance). Les mutations consistent \u00e0 modifier les valeurs des g\u00e8nes des organismes. L\u2019\u00e9chelle de mutation est d\u00e9finie \u00e0 0,1, ce qui signifie que les modifications de g\u00e8nes seront tir\u00e9es d\u2019une distribution normale avec un \u00e9cart-type de 0,1.</p> </li> <li> <p> De plus, il y a une probabilit\u00e9 de 0,01 (1% de chance) d\u2019ajouter ou de supprimer des g\u00e8nes lors de la mutation des organismes.</p> </li> <li> <p> Ces param\u00e8tres contr\u00f4lent le niveau de diversit\u00e9 g\u00e9n\u00e9tique et de variation au sein de la population, ainsi que la probabilit\u00e9 de modifications importantes des caract\u00e9ristiques des organismes au fil des \u00e9tapes de l\u2019\u00e9volution.</p> </li> </ul> <pre><code>evolve(0.01, 0.1, 0.01)\n</code></pre> Image de test (Input) <p></p> R\u00e9sultat final (Output) <p></p>"},{"location":"#conclusion","title":"Conclusion","text":"<p>Conclusion</p> <p>Vous pouvez observer une am\u00e9lioration des images g\u00e9n\u00e9r\u00e9es \u00e0 chaque it\u00e9ration. Cependant, en raison des contraintes de ressources, je n\u2019ai pas pu poursuivre l\u2019ex\u00e9cution du code car j\u2019utilisais Google Colab, qui est limit\u00e9 en termes de temps. Pour obtenir le r\u00e9sultat final de mon algorithme, il serait n\u00e9cessaire de souscrire \u00e0 Google Colab Pro.</p>"}]}